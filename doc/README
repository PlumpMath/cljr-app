@Clojure
 - Is a dialect for Lisp, Lisp is a special langauge. 
 - Is homoiconic with almost no syntax.
 - Has a full macrosystem also supports metaprogramming. 
 - Is a functional language with first-class functions.
 - Immutable data structures.
 - Inbuilt concurrency semantics. 
 - Hosted on the extremely mature and performant JavaVM.
 - Seamless interoperability with Java code.
 - General purpose as well as dynamic programming language.
 - Excellently suited for domain-specific langaue style of programming.

@Why Clojure?
 - A Lisp
 - For functional programming
 - Symbiotic with an established Platform
 - Designed for Concurrency
 - Code as data.

@Clojure unique features
 01. Dynamic Development.
 02. Functional Programming.
 03. Lisp.
 04. Runtime Plymorphism.
 05. Concurrent Programming.
 06. Immutability.
 07. Higer-order functions.
 08. Laziness.
 09. Excellent concurrency semantics.
 10. Software Transaction Memory.
 11. Hosted on the JVM

@Clojure program structure
 01. Literals
	- Strings
	- Characters
	- nil
	- true
	- false
	- integers
	- floating point numbers
	- ratios
 02. Vectors
 03. Lists
 04. Maps
 05. Sets
 06. Symbols
 07. Special Forms
	- def
	- if
	- do
	- let
	- quote
	- var
	- fn
	- loop
	- recure
	- throw
	- try
	- monitor-enter
	- monitor-exit
	- other special forms
		- dot(.)
		- new
		- set!
 08. Composite Forms
 09. Function Calls
 10. Macros

@Clojure and OOP Paradigm
 - Modularity    => Clojure namespacing mechanism
 - Polymorphism  => Clojure Multimethods
 - Encapsulation => Clojure functions
 - Reusability   => Clojure functions

@Function
 A function, is a mathematical sense, expresses the idea that one quantity
 (the argument of the function, also known as the input) completely
 determines another quantity (the value, or the output).
	
@Clojure Functions
 In Clojure, all functions are first-class objects.
 - Can be dynamically created at any point during the execution of the program.
 - Are not intrinsically named, can be bound to symbols.
 - Can be stored as value in any data structure.
 - Can be passed to, and returned from, other functions

@Closure Oriented Programming
 - Functions as parameter
 - Functions as return value
 - Composing functions

@Clojure coding guidelines
 1. Start every source file with a namespace declaration using ns.
 2. Use :import and :use expression in ns to describe the classes and namespaces it depends on.
 3. Always use :only option of :use to make it clear which symbols you need from the other namespace.
 4. Reuse good names, add the :refer-clojure expression to ns if needed.
 5. Structure your source files to avoid the need for forward declarations. Place "primitive" definations near the top and the "composite" definations that depend on them toward the bottom.

@Reference
 1. Practical Clojure by Luke VanderHart and Stuart Sierra
 2. Clojure In Action - Amit Rathore
